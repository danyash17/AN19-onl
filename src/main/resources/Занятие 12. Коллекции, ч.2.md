Set - https://docs.oracle.com/javase/8/docs/api/java/util/Set.html
NavigableSet - https://docs.oracle.com/javase/8/docs/api/java/util/NavigableSet.html
Red-Black Tree - https://www.cs.usfca.edu/~galles/visualization/RedBlack.html
Map - https://metanit.com/java/tutorial/5.8.php
TreeMap - https://javarush.com/groups/posts/2584-osobennosti-treemap
Методы TreeMap - https://metanit.com/java/tutorial/5.9.php
Устройство HashMap - https://habr.com/ru/articles/128017/
Ещё про HashMap - https://blog.skillfactory.ru/glossary/hashmap/

```java
import java.util.HashMap;

public class HashMapDemo {
    public static void main(String[] args) {
        // Создание HashMap с ключами типа String и значениями типа Integer (цена          фруктов)
        HashMap<String, Integer> map = new HashMap<>();

        // Добавление элементов в HashMap
        map.put("Apple", 50);
        map.put("Banana", 30);
        map.put("Mango", 20);

        // Вывод размера и содержимого HashMap
        System.out.println("Размер HashMap: " + map.size());
        System.out.println("Содержимое HashMap: " + map);

        // Получение значения по ключу
        String key = "Apple";
        if (map.containsKey(key)) {
            Integer value = map.get(key);
            System.out.println("Значение для ключа \"" + key + "\": " + value);
        }

        // Удаление элемента по ключу
        map.remove("Banana");
        System.out.println("Содержимое HashMap после удаления \"Banana\": " + map);

        // Проверка наличия ключа
        if (map.containsKey("Mango")) {
            System.out.println("Ключ \"Mango\" присутствует в HashMap.");
        } else {
            System.out.println("Ключ \"Mango\" отсутствует в HashMap.");
        }
    }
}

```

```java
import java.util.TreeMap;

public class TreeMapDemo {
    public static void main(String[] args) {
        // Создание TreeMap с ключами типа String и значениями типа Integer
        TreeMap<String, Integer> map = new TreeMap<>();

        // Добавление элементов в TreeMap
        map.put("Apple", 50);
        map.put("Banana", 30);
        map.put("Mango", 20);

        // Вывод размера и содержимого TreeMap
        System.out.println("Размер TreeMap: " + map.size());
        System.out.println("Содержимое TreeMap: " + map);

        // Получение значения по ключу
        String key = "Apple";
        if (map.containsKey(key)) {
            Integer value = map.get(key);
            System.out.println("Значение для ключа \"" + key + "\": " + value);
        }

        // Удаление элемента по ключу
        map.remove("Banana");
        System.out.println("Содержимое TreeMap после удаления \"Banana\": " + map);

        // Проверка наличия ключа
        if (map.containsKey("Mango")) {
            System.out.println("Ключ \"Mango\" присутствует в TreeMap.");
        } else {
            System.out.println("Ключ \"Mango\" отсутствует в TreeMap.");
        }

        // Вывод всех ключей и значений
        System.out.println("Все ключи: " + map.keySet());
        System.out.println("Все значения: " + map.values());
    }
}

```

```java
import java.util.TreeMap;

public class TreeMapDemo {
    public static void main(String[] args) {
        // Создание TreeMap с ключами типа String и значениями типа Integer
        TreeMap<String, Integer> map = new TreeMap<>();

        // Добавление элементов в TreeMap
        map.put("Apple", 50);
        map.put("Banana", 30);
        map.put("Mango", 20);

        // Вывод размера и содержимого TreeMap
        System.out.println("Размер TreeMap: " + map.size());
        System.out.println("Содержимое TreeMap: " + map);

        // Получение значения по ключу
        String key = "Apple";
        if (map.containsKey(key)) {
            Integer value = map.get(key);
            System.out.println("Значение для ключа \"" + key + "\": " + value);
        }

        // Удаление элемента по ключу
        map.remove("Banana");
        System.out.println("Содержимое TreeMap после удаления \"Banana\": " + map);

        // Проверка наличия ключа
        if (map.containsKey("Mango")) {
            System.out.println("Ключ \"Mango\" присутствует в TreeMap.");
        } else {
            System.out.println("Ключ \"Mango\" отсутствует в TreeMap.");
        }

        // Вывод всех ключей и значений
        System.out.println("Все ключи: " + map.keySet());
        System.out.println("Все значения: " + map.values());
    }
}

```

```java
import java.util.TreeSet;

public class TreeSetDemo {
    public static void main(String[] args) {
        // Создание TreeSet с элементами типа String
        TreeSet<String> set = new TreeSet<>();

        // Добавление элементов в TreeSet
        set.add("Apple");
        set.add("Banana");
        set.add("Mango");

        // Вывод размера и содержимого TreeSet
        System.out.println("Размер TreeSet: " + set.size());
        System.out.println("Содержимое TreeSet: " + set);

        // Проверка наличия элемента
        String element = "Apple";
        if (set.contains(element)) {
            System.out.println("Элемент \"" + element + "\" присутствует в TreeSet.");
        }

        // Удаление элемента
        set.remove("Banana");
        System.out.println("Содержимое TreeSet после удаления \"Banana\": " + set);

        // Итерация по элементам TreeSet
        System.out.println("Элементы TreeSet:");
        for (String item : set) {
            System.out.println(item);
        }

        // Вывод первого и последнего элемента
        System.out.println("Первый элемент: " + set.first());
        System.out.println("Последний элемент: " + set.last());
    }
}

```

```java
public class Person { public String firstName; public String lastName; public int age; public Person(String firstName, String lastName, int age) { this.firstName = firstName; this.lastName = lastName; this.age = age; } }

import java.util.Comparator; import java.util.Map; import java.util.TreeMap; public class Main { public static void main(String[] args) { TreeMap<Person, Integer> map = new TreeMap<>(Comparator.comparingInt(o -> o.age)); map.put(new Person("John", "Smith", 17), 0); map.put(new Person("Ivan", "Petrenko", 65), 0); map.put(new Person("Pedro", "Escobar", 32), 0); map.put(new Person("Radion", "Pyatkin", 14), 0); map.put(new Person("Sergey", "Vashkevich", 19), 0); Person firstAdultPerson = map.navigableKeySet().stream().filter(person -> person.age>18).findFirst().get(); Map<Person, Integer> youngPeopleMap = map.headMap(firstAdultPerson, false); Map<Person, Integer> adultPeopleMap = map.tailMap(firstAdultPerson, true); showAdvertisementToYoung(youngPeopleMap); showAdvertisementToAdult(adultPeopleMap); } public static void showAdvertisementToYoung(Map map){} public static void showAdvertisementToAdult(Map map){} }

```

```java
import java.util.HashMap;
import java.util.Map;

public class CountryIsoCodeExample {
    public static void main(String[] args) {
        Map<String, String> countryIsoCodes = new HashMap<>();

        countryIsoCodes.put("Россия", "RU");
        countryIsoCodes.put("США", "US");
        countryIsoCodes.put("Китай", "CN");
        countryIsoCodes.put("Франция", "FR");
        countryIsoCodes.put("Германия", "DE");

        String country = "США";
        String isoCode = countryIsoCodes.get(country);
        
        if (isoCode != null) {
            System.out.println("ISO-код для " + country + ": " + isoCode);
        } else {
            System.out.println("Страна не найдена.");
        }

        System.out.println("\nСписок всех стран и их ISO-кодов:");
        for (Map.Entry<String, String> entry : countryIsoCodes.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}

```
### HashMap

**Сильные стороны:**

- **Быстрая вставка и доступ:** Операции `put()`, `get()`, и `remove()` имеют среднюю временную сложность
    
    O(1)
    
    [, что делает `HashMap` очень быстрой для большинства операций](https://www.baeldung.com/java-treemap-vs-hashmap)[1](https://www.baeldung.com/java-treemap-vs-hashmap)[2](https://www.javaguides.net/2023/10/difference-between-hashmap-and-treemap-in-java.html).
- [**Гибкость:** `HashMap` позволяет хранить один `null` ключ и множество `null` значений](https://www.baeldung.com/java-treemap-vs-hashmap)[1](https://www.baeldung.com/java-treemap-vs-hashmap).

**Слабые стороны:**

- [**Нет упорядоченности:** `HashMap` не гарантирует порядок элементов, что может быть проблемой, если вам нужно хранить данные в определенном порядке](https://www.baeldung.com/java-treemap-vs-hashmap)[1](https://www.baeldung.com/java-treemap-vs-hashmap).
- **Худший случай:** В редких случаях, когда происходит много коллизий, временная сложность может ухудшиться до
    
    O(n)
    
    [](https://www.baeldung.com/java-treemap-vs-hashmap)[2](https://www.javaguides.net/2023/10/difference-between-hashmap-and-treemap-in-java.html).

### TreeMap

**Сильные стороны:**

- [**Упорядоченность:** `TreeMap` хранит элементы в отсортированном порядке, что может быть полезно для задач, требующих упорядоченных данных](https://www.baeldung.com/java-treemap-vs-hashmap)[1](https://www.baeldung.com/java-treemap-vs-hashmap).
- [**Навигационные методы:** `TreeMap` предоставляет методы для получения первого, последнего, наибольшего и наименьшего ключей, что может быть полезно в некоторых сценариях](https://www.geeksforgeeks.org/hashmap-treemap-java/)[3](https://www.geeksforgeeks.org/hashmap-treemap-java/).
- Не подвержен коллизиям.

**Слабые стороны:**

- **Медленнее, чем HashMap:** Операции `put()`, `get()`, и `remove()` имеют временную сложность
    
    O(logn)
    
    [, что медленнее по сравнению с `HashMap`](https://www.baeldung.com/java-treemap-vs-hashmap)[2](https://www.javaguides.net/2023/10/difference-between-hashmap-and-treemap-in-java.html).
- [**Нет поддержки null ключей:** `TreeMap` не позволяет хранить `null` ключи](https://www.baeldung.com/java-treemap-vs-hashmap)[1](https://www.baeldung.com/java-treemap-vs-hashmap).

### Когда использовать HashMap:

- **Быстрый доступ:** Когда вам нужно быстрое добавление, удаление и доступ к элементам.
- **Нет необходимости в порядке:** Когда порядок элементов не имеет значения.
- **Работа с null:** Когда вам нужно хранить `null` ключи и значения.

### Когда использовать TreeMap:

- **Упорядоченные данные:** Когда вам нужно хранить элементы в отсортированном порядке.
- **Навигация по ключам:** Когда вам нужны методы для получения первого, последнего, наибольшего и наименьшего ключей.
- **Нет необходимости в null ключах:** Когда вы не планируете использовать `null` ключи.

## Задачи на закрепление

1. **Уникальные пользователи**: Создайте программу, которая принимает имен пользователей на ввод и выводит только уникальные имена, используя HashSet.
    
2. **Телефонная книга**: Реализуйте телефонную книгу с помощью HashMap, где ключом будет имя контакта, а значением — номер телефона. Добавьте возможность поиска номера по имени.
    
3. **Словарь**: Создайте программу, которая будет хранить слова и их определения с помощью TreeMap. Реализуйте функции добавления, удаления и поиска слов.
    
4. **Сортировка дат**: Напишите программу, которая принимает список дат и выводит их в отсортированном порядке, используя TreeSet.
    
5. **Подсчет частоты слов**: Реализуйте программу, которая принимает текст и подсчитывает частоту каждого слова, используя HashMap.
    
6. **Уникальные числа**: Напишите программу, которая принимает список чисел и выводит только уникальные числа, используя HashSet.
    
7. **Сортировка студентов по баллам**: Создайте программу, которая хранит имена студентов и их баллы в TreeMap и выводит список студентов в порядке убывания баллов.
    
8. **Календарь событий**: Реализуйте календарь событий с помощью TreeMap, где ключом будет дата, а значением — описание события. Добавьте возможность добавления, удаления и поиска событий по дате.
    
9. **Анализ посещаемости**: Напишите программу, которая принимает список посещений студентов (имя и дата) и выводит уникальные имена студентов, используя HashSet.
    
10. **Словарь синонимов**: Создайте программу, которая хранит слова и их синонимы с помощью HashMap. Реализуйте функции добавления, удаления и поиска синонимов для заданного слова.
11. **Уникальные продукты**: Создайте программу, которая принимает список продуктов и выводит только уникальные названия продуктов, используя HashSet.
    
12. **Каталог книг**: Реализуйте каталог книг с помощью HashMap, где ключом будет ISBN книги, а значением — название книги. Добавьте возможность поиска книги по ISBN.
    
13. **Сортировка сотрудников по возрасту**: Напишите программу, которая хранит имена сотрудников и их возраст в TreeMap и выводит список сотрудников в порядке возрастания возраста.
    
14. **Учет посещений**: Создайте программу, которая принимает список посещений (имя и дата) и выводит уникальные даты посещений, используя TreeSet.
    
15. **Подсчет голосов**: Реализуйте программу для подсчета голосов на выборах, где ключом будет имя кандидата, а значением — количество голосов, используя HashMap.
    
16. **Уникальные слова в тексте**: Напишите программу, которая принимает текст и выводит все уникальные слова, используя HashSet.
    
17. **Сортировка товаров по цене**: Создайте программу, которая хранит названия товаров и их цены в TreeMap и выводит список товаров в порядке возрастания цены.
    
18. **Календарь задач**: Реализуйте календарь задач с помощью TreeMap, где ключом будет дата, а значением — описание задачи. Добавьте возможность добавления, удаления и поиска задач по дате.
    
19. **Анализ посещаемости веб-сайта**: Напишите программу, которая принимает список посещений веб-сайта (IP-адрес и дата) и выводит уникальные IP-адреса, используя HashSet.
    
20. **Словарь антонимов**: Создайте программу, которая хранит слова и их антонимы с помощью HashMap. Реализуйте функции добавления, удаления и поиска антонимов для заданного слова.

Вероятность хэш коллизии двух объектов при идеальной хэш функции - 2.328 × 10^-8% = 0.00000002328%

## Дополнительные задачи

1. Система почтовых отправлений

- Описание задачи: Создайте систему для управления почтовыми отправлениями, где каждая отправка имеет уникальный трек-номер, адрес получателя, номер склада на котором хранится отправление. Почтовая система должна иметь метод для получения всех посылок определенного склада, получения номера склада по трек номеру посылки, а также метод отправки посылки. Важно - программа должна помнить отправленные посылки, а также разделять отправленные и неотправленные.
- Подход к решению:
	- Класс MailItem: будет представлять почтовую отправку. В нем - поля `trackNumber`, `address`, `storageNum`
	- Класс MailSystem: будет представлять систему управления. В ней - коллекция для хранения почтовых отправлений и методы для работы.
- Приоритет: скорость поиска. Выбирайте такую коллекцию, чтобы обеспечивать самый быстрый поиск по трек номеру для огромной базы отправлений.

2. Разведывательный архив

- Описание задачи: Создайте систему для хранения и поиска отчетов секретной разведывательной службы. Каждый отчет имеет уникальный номер (в порядке возрастания, шаблон номера: "<уровень секретности>/<порядковый номер>", пример - 3/142), название, досье (в виде строки) и уровень секретности (3 - общий доступ, 2 - секретно, 1 - совершенно секретно). При запуске программа должна просить ввести на консоль уровень доступа сотрудника. После ввода, должны выводиться все секретные материалы, к которым имеет доступ сотрудник (постарайтесь переопределить toString так, чтобы вывод был хорошо отформатированным). Опишите метод поиска отчета по его номеру. Опишите методы получения первого и последнего отчета архива. 
- Подход к решению:
	- Класс IntelligenceObject: будет представлять разведотчет. В нем - поля `number`, `report`, `secrecyLevel`
	- Класс IntelligenceArchive: будет представлять систему управления архивом. В нем - коллекция для хранения отчетов и методы для работы.
- Приоритет: порядок. Министр разведки будет недоволен, если вдруг окажется, что отчеты хранятся вразнобой. Выбирайте такую коллекцию, чтобы обеспечивать порядок добавления отчетов.

3. Регистрация юридического лица

- Описание задачи: Создайте систему для регистрации юридических лиц, где каждое юридическое лицо имеет уникальный идентификатор и название. Пользователь должен вводить название юридической организации через консоль, программа должна проверять в существующей базе, свободно ли это наименование. Если да, она должна генерировать ему уникальный номер (используйте класс UUID) и сообщать пользователю, а также сохранять зарегистрированное юрлицо. Обеспечьте ввод с помощью бесконечного цикла.
- Подход к решению:
	- Класс LegalEntity: будет представлять юридическое лицо. В нем - поля `id`, `name`
	- Класс RegistrationSystem: будет представлять систему регистрации. В нем - коллекция для хранения существующих юрлиц.
- Приоритет: уникальность. Выбирайте такую коллекцию, чтобы исключить дублирование юридических лиц.