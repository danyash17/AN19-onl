Vector, Stack - https://stackoverflow.com/questions/1386275/why-is-java-vector-and-stack-class-considered-obsolete-or-deprecated
Queue - https://www.examclouds.com/ru/java/java-core-russian/interface-queue
Deque - https://metanit.com/java/tutorial/5.7.php

## Livecoding

#### Основные методы `ArrayList`

1. **Создание и добавление элементов:**

```java
import java.util.ArrayList;

public class ArrayListExample {
    public static void main(String[] args) {
        // Создание ArrayList
        ArrayList<String> list = new ArrayList<>();

        // Добавление элементов
        list.add("Apple");
        list.add("Banana");
        list.add("Cherry");

        // Вывод элементов
        System.out.println("ArrayList: " + list);
    }
}
```

2. **Доступ к элементам:**


```java
// Получение элемента по индексу
String fruit = list.get(1); // Banana
System.out.println("Element at index 1: " + fruit);
```

3. **Изменение элементов:**


```java
// Изменение элемента по индексу
list.set(1, "Blueberry");
System.out.println("Updated ArrayList: " + list);
```


4. **Удаление элементов:**


```java
// Удаление элемента по индексу
list.remove(2); // Удаляет "Cherry"
System.out.println("ArrayList after removal: " + list);

// Удаление элемента по значению
list.remove("Apple");
System.out.println("ArrayList after removal: " + list);
```


5. **Размер списка:**

```java
int size = list.size();
System.out.println("Size of ArrayList: " + size);
```


#### Основные методы `LinkedList`

1. **Создание и добавление элементов:**

```java
import java.util.LinkedList;

public class LinkedListExample {
    public static void main(String[] args) {
        // Создание LinkedList
        LinkedList<String> list = new LinkedList<>();

        // Добавление элементов
        list.add("Dog");
        list.add("Cat");
        list.add("Horse");

        // Вывод элементов
        System.out.println("LinkedList: " + list);
    }
}
```

2. **Добавление элементов в начало и конец:**


```java
// Добавление в начало
list.addFirst("Elephant");

// Добавление в конец
list.addLast("Lion");
System.out.println("LinkedList after additions: " + list);
```


3. **Удаление элементов:**


```java
// Удаление первого элемента
list.removeFirst();
System.out.println("LinkedList after removing first: " + list);

// Удаление последнего элемента
list.removeLast();
System.out.println("LinkedList after removing last: " + list);
```

4. **Доступ к элементам:**


```java
// Получение первого элемента
String first = list.getFirst();
System.out.println("First element: " + first);

// Получение последнего элемента
String last = list.getLast();
System.out.println("Last element: " + last);
```

5. **Методы `poll`, `peek`, `offer`:**

```java
// Получение и удаление первого элемента (или null, если очередь пуста)
String firstElement = list.poll();
System.out.println("Polled element: " + firstElement);
System.out.println("LinkedList after poll: " + list);

// Получение первого элемента без удаления (или null, если очередь пуста)
String peekElement = list.peek();
System.out.println("Peeked element: " + peekElement);
System.out.println("LinkedList after peek: " + list);

// Добавление элемента в конец очереди
list.offer("Tiger");
System.out.println("LinkedList after offer: " + list);
```

6. **Методы `removeFirst`, `removeLast`, `getFirst`, `getLast`:**

```java
// Удаление первого элемента
list.removeFirst();
System.out.println("LinkedList after removing first: " + list);

// Удаление последнего элемента
list.removeLast();
System.out.println("LinkedList after removing last: " + list);

// Получение первого элемента
String first = list.getFirst();
System.out.println("First element: " + first);

// Получение последнего элемента
String last = list.getLast();
System.out.println("Last element: " + last);
```

#### Основные методы `ArrayDeque`

1. **Создание и добавление элементов:**

```java
import java.util.ArrayDeque;

public class ArrayDequeExample {
    public static void main(String[] args) {
        // Создание ArrayDeque
        ArrayDeque<String> deque = new ArrayDeque<>();

        // Добавление элементов
        deque.add("Red");
        deque.add("Green");
        deque.add("Blue");

        // Вывод элементов
        System.out.println("ArrayDeque: " + deque);
    }
}
```

2. **Добавление элементов в начало и конец:**


```java
// Добавление в начало
deque.addFirst("Yellow");

// Добавление в конец
deque.addLast("Purple");
System.out.println("ArrayDeque after additions: " + deque);
```


3. **Удаление элементов:**


```java
// Удаление первого элемента
deque.removeFirst();
System.out.println("ArrayDeque after removing first: " + deque);

// Удаление последнего элемента
deque.removeLast();
System.out.println("ArrayDeque after removing last: " + deque);
```

4. **Доступ к элементам:**


```java
// Получение первого элемента
String first = deque.getFirst();
System.out.println("First element: " + first);

// Получение последнего элемента
String last = deque.getLast();
System.out.println("Last element: " + last);
```

5. **Методы `poll` и `peek`:**

```java
// Получение и удаление первого элемента (или null, если очередь пуста)
String firstElement = deque.poll();
System.out.println("Polled element: " + firstElement);
System.out.println("ArrayDeque after poll: " + deque);

// Получение первого элемента без удаления (или null, если очередь пуста)
String peekElement = deque.peek();
System.out.println("Peeked element: " + peekElement);
System.out.println("ArrayDeque after peek: " + deque);
```

6. **Методы `offer`, `remove` и `element`:**


```java
// Добавление элемента в конец очереди
deque.offer("Yellow");
System.out.println("ArrayDeque after offer: " + deque);

// Удаление и получение первого элемента (или выброс исключения, если очередь пуста)
String removedElement = deque.remove();
System.out.println("Removed element: " + removedElement);
System.out.println("ArrayDeque after remove: " + deque);

// Получение первого элемента без удаления (или выброс исключения, если очередь пуста)
String element = deque.element();
System.out.println("Element: " + element);
System.out.println("ArrayDeque after element: " + deque);
```

## Примеры использования

### Задача 1: ArrayList

**Ситуация:** Вам нужно хранить и обрабатывать большой список студентов, где частые операции включают доступ к элементам по индексу и добавление новых студентов в конец списка.

**Задача:** Напишите программу, которая:

1. Создает список студентов с помощью `ArrayList`.
2. Добавляет 1000 студентов в список.
3. Получает и выводит информацию о 500-м студенте.
4. Удаляет 200-го студента.

**Важные методы:**

- `add(E e)`: добавляет элемент в конец списка.
- `get(int index)`: возвращает элемент по указанному индексу.
- `remove(int index)`: удаляет элемент по указанному индексу.
- `set(int index, E element)`: заменяет элемент по указанному индексу.

```java
import java.util.ArrayList;

public class StudentList {
    public static void main(String[] args) {
        ArrayList<String> students = new ArrayList<>();
        
        // Добавление студентов
        for (int i = 1; i <= 1000; i++) {
            students.add("Student " + i);
        }
        
        // Получение информации о 500-м студенте
        System.out.println("500-й студент: " + students.get(499));
        
        // Удаление 200-го студента
        students.remove(199);
        
        // Вывод размера списка после удаления
        System.out.println("Размер списка после удаления: " + students.size());
    }
}
```

### Задача 2: LinkedList (История браузера)

**Ситуация:** Вам нужно реализовать историю браузера, где частые операции включают добавление новых страниц в начало и удаление произвольных страниц.

**Задача:** Напишите программу, которая:

1. Создает историю браузера с помощью `LinkedList`.
2. Добавляет 5 посещенных страниц.
3. Удаляет произвольные страницы и выводит текущую историю.

**Важные методы:**

- `addFirst(E e)`: добавляет элемент в начало списка.
- `remove(int index)`: удаляет элемент по указанному индексу.
- `get(int index)`: возвращает элемент по указанному индексу.

```java
import java.util.LinkedList;

public class BrowserHistory {
    public static void main(String[] args) {
        LinkedList<String> history = new LinkedList<>();
        
        // Добавление посещенных страниц
        history.addFirst("Page 1");
        history.addFirst("Page 2");
        history.addFirst("Page 3");
        history.addFirst("Page 4");
        history.addFirst("Page 5");
        
        // Вывод текущей истории
        System.out.println("Текущая история: " + history);
        
        // Удаление произвольных страниц
        history.remove(2); // Удаление 3-й страницы (индекс 2)
        history.remove(0); // Удаление 1-й страницы (индекс 0)
        
        // Вывод истории после удаления
        System.out.println("История после удаления: " + history);
    }
}
```

### Задача 3: ArrayDeque (Очередь на посадку в самолет)

**Ситуация:** Вам нужно реализовать систему очереди на посадку в самолет, где пассажиры могут добавляться в очередь и вызываться на посадку с обоих концов очереди.

**Задача:** Напишите программу, которая:

1. Создает очередь на посадку с помощью `ArrayDeque`.
2. Добавляет 5 пассажиров в начало и 5 пассажиров в конец очереди.
3. Удаляет и выводит пассажиров с обоих концов очереди до тех пор, пока очередь не станет пустой.

**Важные методы:**

- `addFirst(E e)`: добавляет элемент в начало очереди.
- `addLast(E e)`: добавляет элемент в конец очереди.
- `removeFirst()`: удаляет и возвращает первый элемент очереди.
- `removeLast()`: удаляет и возвращает последний элемент очереди.

Java

```java
import java.util.ArrayDeque;

public class BoardingQueue {
    public static void main(String[] args) {
        ArrayDeque<String> boardingQueue = new ArrayDeque<>();
        
        // Добавление пассажиров в начало и конец очереди
        for (int i = 1; i <= 5; i++) {
            boardingQueue.addFirst("Пассажир " + i + " (начало)");
            boardingQueue.addLast("Пассажир " + i + " (конец)");
        }
        
        // Удаление и вывод пассажиров с обоих концов очереди
        while (!boardingQueue.isEmpty()) {
            System.out.println("Посадка: " + boardingQueue.removeFirst());
            if (!boardingQueue.isEmpty()) {
                System.out.println("Посадка: " + boardingQueue.removeLast());
            }
        }
    }
}
```



## Критерии выбора
### ArrayList

- **Основана на массиве**.
- **Операции**:
    - Доступ по индексу:
        
        O(1)
        
    - Добавление в конец:
        
        O(1)
        
        (амортизированное)
    - Вставка/удаление в середине:
        
        O(n)
        
- **Использование**: Подходит для случаев, когда требуется быстрый доступ по индексу и редкие вставки/удаления в середине.

### LinkedList

- **Основана на двусвязном списке**.
- **Операции**:
    - Доступ по индексу:
        
        O(n)
        
    - Добавление/удаление в начало/конец:
        
        O(1)
        
    - Вставка/удаление в середине:
        
        O(n)
        
- **Использование**: Хороша для частых вставок/удалений в любой точке списка и когда не требуется быстрый доступ по индексу.

### ArrayDeque

- **Основана на массиве**.
- **Операции**:
    - Добавление/удаление в начало/конец:
        
        O(1)
        
    - Доступ по индексу:
        
        O(n)
        
        (не поддерживается напрямую)
- **Использование**: Идеальна для реализации очередей и стеков, где важны операции добавления и удаления с обоих концов, а также быстрого доступа по индексу.

## Задачи для студентов

1. ArrayList: Список студентов
Задача: Создайте программу для управления списком студентов в учебном заведении. Необходимо добавлять, удалять и находить студентов по имени.

Сильные стороны:
- Быстрый доступ по индексу: Можно быстро получить информацию о студенте по индексу.
- Эффективные операции добавления в конец: Добавление новых студентов происходит быстро.

Пример кода:
```java
ArrayList<String> students = new ArrayList<>();
students.add("Alice");
students.add("Bob");
// Поиск студента
int index = students.indexOf("Bob");
if (index != -1) {
    System.out.println("Студент найден: " + students.get(index));
}
```

2. LinkedList: Очередь обслуживания клиентов
Задача: Реализуйте систему обслуживания клиентов, где клиенты могут приходить и уходить в любое время. Используйте LinkedList для хранения клиентов.

Сильные стороны:
- Эффективные операции вставки и удаления: Можно легко добавлять и удалять клиентов из начала и конца списка без необходимости перемещения других элементов.

Пример кода:
```java
LinkedList<String> queue = new LinkedList<>();
queue.add("Client 1"); // Клиент пришел
queue.add("Client 2");

// Обслуживание клиента
String servedClient = queue.removeFirst();
System.out.println("Обслуживается: " + servedClient);

```

3. ArrayDeque: Система отмены действий в текстовом редакторе
Задача: Реализуйте функциональность отмены и повтора действий в текстовом редакторе. Используйте ArrayDeque для хранения выполненных действий.

Сильные стороны:
- Быстрые операции добавления и удаления с обоих концов: Можно легко добавлять новые действия и удалять последние, когда пользователь решает отменить или повторить действие.

Пример кода:
```java
import java.util.ArrayDeque;

public class TextEditor {
    private ArrayDeque<String> undoStack = new ArrayDeque<>();
    private ArrayDeque<String> redoStack = new ArrayDeque<>();

    // Метод для выполнения действия
    public void performAction(String action) {
        undoStack.push(action); // Сохраняем действие для отмены
        redoStack.clear(); // Очищаем стек повторов
        System.out.println("Выполнено действие: " + action);
    }

    // Метод для отмены последнего действия
    public void undo() {
        if (!undoStack.isEmpty()) {
            String lastAction = undoStack.pop();
            redoStack.push(lastAction); // Сохраняем для повтора
            System.out.println("Отменено действие: " + lastAction);
        } else {
            System.out.println("Нет действий для отмены.");
        }
    }

    // Метод для повторного выполнения последнего отмененного действия
    public void redo() {
        if (!redoStack.isEmpty()) {
            String lastUndoneAction = redoStack.pop();
            undoStack.push(lastUndoneAction); // Сохраняем снова для отмены
            System.out.println("Повторено действие: " + lastUndoneAction);
        } else {
            System.out.println("Нет действий для повтора.");
        }
    }

    public static void main(String[] args) {
        TextEditor editor = new TextEditor();
        editor.performAction("Написать текст");
        editor.performAction("Исправить опечатку");
        editor.undo();
        editor.redo();
    }
}
```

### Итог - концентрируйтесь на сильных сторонах коллекций при их выборе. ArrayList - очень универсальная коллекция, ее можно использовать в 70% случаев, отлично подходит для быстрого доступа и добавления в конец. LinkedList подойдет, когда мы часто модифицируем коллекцию в произвольных местах, из-за того, что коллекция основана не на массиве, а на узлах, эти процедуры она будет выполнять быстрее. ArrayDeque - отличная коллекция, если мы часто добавляем / убираем элементы с начала и конца (из-за O(1) сложности на обе операции по причине использования ссылок на начало и конец очереди, ArrayList при вставке в начало сдвигает все элемента вправо, т.к. не имеет ссылок)

## Домашка


Создайте программу для управления библиотекой, используя коллекции Java. Ваша программа должна включать следующие функции:

1. Создание класса Book:
   - Поля: title, author, isbn, year.
   - Конструктор и геттеры/сеттеры для всех полей.
   - Переопределите метод toString() для удобного отображения информации о книге.
   - Переопределите методы equals(), hashCode()

2. Создание класса Library:
   - Используйте ArrayList для хранения списка книг.
   - Реализуйте следующие методы:
     - addBook(Book book): добавление книги в библиотеку.
     - removeBook(String isbn): удаление книги по ISBN.
     - findBookByTitle(String title): поиск книги по названию.
     - listAllBooks(): вывод всех книг в библиотеке.

3. Создание класса Main:
   - Реализуйте меню, позволяющее пользователю выполнять следующие действия:
     - Добавить книгу
     - Удалить книгу
     - Найти книгу по названию
     - Вывести список всех книг
     - Завершить программу

4. Дополнительные требования:
   - Обработайте возможные исключения (например, при попытке удалить несуществующую книгу).
   - Добавьте возможность поиска книг по автору (метод findBooksByAuthor(String author)).

## Дополнительные задачи

Задача 1: Трекер задач
Напишите программу для мониторинга рабочих задач. У задачи должно быть поля "описание", "номер", "дата начала", "активен - boolean". Класс `Board` должен содержать методы для:
1) Подсчета всех задач
2) Подсчета активных задач
3) Нахождения самой долгоживущей задачи
4) Добавления/удаления задач
Подходящую коллекцию выберите сами, в комментарии аргументируйте выбор.

Задача 2: Программа учета фермы
Напишите программу для учета животных на ферме, используя Java Collections. Животные должны иметь абстрактного предка и поля "кличка", "возраст". Класс `Farm` должен содержать методы для:
1) Подсчета поголовья
2) Подсчета животных одного типа - количество свиней, коров и так далее. Сигнатура метода `public int countSpecific(Animal animal)`
3) Идентификации старейшего/самого молодого животного определенного типа. Сигнатуры методов `public Animal findOldest(Class animal)` и `public Animal findYoungest(Class animal)`
4) Добавления/удаления животных из фермы
Подходящую коллекцию выберите сами, в комментарии аргументируйте выбор.

Задача 3. Игра "Zooma"
Напишите программу для игры в "Zooma" через консоль. Последовательность шаров пусть задается символами Ø, © и ¤ (либо с помощью цветного вывода). Пусть пользователь случайном образом получает один из типов шаров и "стреляет" им в определенное место, вставляя его туда. Три подряд идущих символа уничтожаются. Стартовое количество шаров - 20. Игра заканчивается, когда длина последовательности шаров превышает 30.
Подходящую коллекцию выберите сами, в комментарии аргументируйте выбор.





